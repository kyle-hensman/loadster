name: CI

on:
  push:
    branches: [ main, develop ]
  pull_request:
    types: [ opened, synchronize ]
    branches: [ main, develop ]

env:
  CARGO_TERM_COLOR: always

jobs:
  test:
    name: Test
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
        rust: [stable, beta]
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Rust
      uses: dtolnay/rust-toolchain@master
      with:
        toolchain: ${{ matrix.rust }}

    - name: Cache cargo registry
      uses: actions/cache@v4
      with:
        path: ~/.cargo/registry
        key: ${{ runner.os }}-cargo-registry-${{ hashFiles('**/Cargo.lock') }}

    - name: Cache cargo index
      uses: actions/cache@v4
      with:
        path: ~/.cargo/git
        key: ${{ runner.os }}-cargo-git-${{ hashFiles('**/Cargo.lock') }}

    - name: Cache target directory
      uses: actions/cache@v4
      with:
        path: target
        key: ${{ runner.os }}-target-${{ matrix.rust }}-${{ hashFiles('**/Cargo.lock') }}

    - name: Run tests
      run: cargo test --verbose

    - name: Run tests with all features
      run: cargo test --all-features --verbose

  integration-tests:
    name: Integration Tests
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Rust
      uses: dtolnay/rust-toolchain@stable

    - name: Build release binary
      run: cargo build --release

    - name: Setup test server
      run: |
        # Start a simple HTTP server for testing
        mkdir -p test-server
        echo "Hello World" > test-server/index.html
        python3 -m http.server 8080 --directory test-server &
        sleep 2

    - name: Test basic functionality
      run: |
        ./target/release/loadster http://localhost:8080 -n 10 -c 2
        if [ $? -ne 0 ]; then
          echo "Basic test failed"
          exit 1
        fi

    - name: Test with JSON output
      run: |
        ./target/release/loadster http://localhost:8080 -n 20 -c 5 -o test-report.json
        if [ ! -f test-report.json ]; then
          echo "JSON output file not created"
          exit 1
        fi
        
        # Validate JSON structure
        if ! jq empty test-report.json 2>/dev/null; then
          echo "Invalid JSON output"
          exit 1
        fi
        
        # Check required fields
        jq -e '.url' test-report.json > /dev/null || exit 1
        jq -e '.total_requests' test-report.json > /dev/null || exit 1
        jq -e '.successful' test-report.json > /dev/null || exit 1
        jq -e '.latency.p95_ms' test-report.json > /dev/null || exit 1

    - name: Test help command
      run: |
        ./target/release/loadster --help
        if [ $? -ne 0 ]; then
          echo "Help command failed"
          exit 1
        fi

    - name: Test version command
      run: |
        ./target/release/loadster --version
        if [ $? -ne 0 ]; then
          echo "Version command failed"
          exit 1
        fi

    - name: Test invalid URL handling
      run: |
        ./target/release/loadster invalid-url -n 5 -c 1 || true
        # Should handle gracefully, we just check it doesn't panic

    - name: Upload test report artifact
      uses: actions/upload-artifact@v4
      with:
        name: test-report
        path: test-report.json

  lint:
    name: Lint
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Rust
      uses: dtolnay/rust-toolchain@stable
      with:
        components: rustfmt, clippy

    - name: Check formatting
      run: cargo fmt -- --check

    - name: Run clippy
      run: cargo clippy -- -D warnings

  build:
    name: Build
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Rust
      uses: dtolnay/rust-toolchain@stable

    - name: Build
      run: cargo build --release --verbose

    - name: Upload binary (Unix)
      if: matrix.os != 'windows-latest'
      uses: actions/upload-artifact@v4
      with:
        name: loadster-${{ matrix.os }}
        path: target/release/loadster

    - name: Upload binary (Windows)
      if: matrix.os == 'windows-latest'
      uses: actions/upload-artifact@v4
      with:
        name: loadster-${{ matrix.os }}
        path: target/release/loadster.exe

  security-audit:
    name: Security Audit
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Rust
      uses: dtolnay/rust-toolchain@stable

    - name: Install cargo-audit
      run: cargo install cargo-audit

    - name: Run security audit
      run: cargo audit --json > audit-report.json

    - name: Comment PR with audit report
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        python - <<EOF
        import json
        import requests
        
        # Load audit report
        with open('audit-report.json', 'r') as f:
            audit_data = json.load(f)
            
        # Create comment content
        comment = """
        ### Security Audit Report
        """
        
        if 'vulnerabilities' in audit_data and audit_data['vulnerabilities']:
            comment += """
            ⚠️ Found vulnerabilities in dependencies:
            """
            for advisory in audit_data['vulnerabilities']:
                comment += f"""
            - {advisory['title']} ({advisory['id']})
                • Package: {advisory['package_name']}
                • Version: {advisory['version']}
                • Severity: {advisory['severity']}
                • Advisory: {advisory['advisory_id']}
                • Published: {advisory['date']}
                • Fixed in: {advisory['affected_version']}
                • Recommendation: {advisory['recommendation']}
            """
        else:
            comment += """
            ✓ No known vulnerabilities detected in dependencies.
            """
        
        # Post comment to PR
        pr_number = int("${GITHUB_REF#"pull/"}")
        url = f"https://api.github.com/repos/${GITHUB_REPOSITORY}/issues/{pr_number}/comments"
        headers = {
            'Authorization': f'Bearer ${GITHUB_TOKEN}',
            'Accept': 'application/vnd.github.v3+json'
        }
        
        # Check existing comments and edit if found
        response = requests.get(url, headers=headers)
        existing_comments = response.json()
        
        for existing_comment in existing_comments:
            if '### Security Audit Report' in existing_comment['body']:
                requests.patch(
                    existing_comment['url'],
                    json={'body': comment},
                    headers=headers
                )
                break
        else:
            requests.post(url, json={'body': comment}, headers=headers)
        EOF

  coverage:
    name: Code Coverage
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Rust
      uses: dtolnay/rust-toolchain@stable

    - name: Install tarpaulin
      run: cargo install cargo-tarpaulin

    - name: Generate coverage
      run: cargo tarpaulin --out json --output-dir coverage

    # - name: Upload coverage to Codecov
    #   uses: codecov/codecov-action@v4
    #   with:
    #     files: ./coverage/cobertura.xml
    #     fail_ci_if_error: false

    - name: Upload test report artifact
      uses: actions/upload-artifact@v4
      with:
        name: coverage-report
        path: ./coverage/tarpaulin-report.json

    - name: Comment PR with coverage
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
          python - <<EOF
          import json
          import requests
          
          # Load JSON report
          with open('./coverage/tarpaulin-report.json', 'r') as f:
              coverage_report = json.load(f)
              
          # Calculate overall coverage
          total_lines = sum(len(file['covered']) for file in coverage_report.values())
          covered_lines = sum(sum(1 for hits in file['covered'].values() if hits > 0) 
                            for file in coverage_report.values())
          coverage_percentage = (covered_lines / total_lines * 100) if total_lines > 0 else 0
          
          # Create comment content
          comment = f"""
          ### Code Coverage Report
          #### Overall Coverage: **{coverage_percentage:.1f}%**
          
          <details>
              <summary>File Coverage Details</summary>
              <table>
                  <tr>
                      <th>File</th>
                      <th>Coverage</th>
                  </tr>
          """
          
          # Add file details
          for filename, coverage_data in sorted(coverage_report.items()):
              total_lines = len(coverage_data['covered'])
              covered_lines = sum(1 for hits in coverage_data['covered'].values() 
                                if hits > 0)
              file_coverage = (covered_lines / total_lines * 100) if total_lines > 0 else 0
              
              comment += f"""
              <tr>
                  <td>{filename}</td>
                  <td>{file_coverage:.1f}%</td>
              </tr>
              """
          
          comment += """
              </table>
          </details>
          """
          
          # Post comment to PR
          pr_number = int("${GITHUB_REF#"pull/"}")
          url = f"https://api.github.com/repos/${GITHUB_REPOSITORY}/issues/{pr_number}/comments"
          headers = {
              'Authorization': f'Bearer ${GITHUB_TOKEN}',
              'Accept': 'application/vnd.github.v3+json'
          }
          
          # Check existing comments and edit if found
          response = requests.get(url, headers=headers)
          existing_comments = response.json()
          
          for existing_comment in existing_comments:
              if '### Code Coverage Report' in existing_comment['body']:
                  requests.patch(
                      existing_comment['url'],
                      json={'body': comment},
                      headers=headers
                  )
                  break
          else:
              requests.post(url, json={'body': comment}, headers=headers)
          EOF